name: "Terraform Staging Deployment"

on:
  push:
    branches:
      - staging
    paths:
      - 'backend/**'
      - 'storefront/**'
      - 'terraform/**'
      - '.github/workflows/terraform-*.yml'
      - 'deploy-trigger'

jobs:
  terraform:
    name: "Deploy to Staging with Terraform"
    runs-on: ubuntu-latest
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_KEY }}
      AWS_REGION: us-east-1
      DIGITALOCEAN_TOKEN: ${{ secrets.DO_API_TOKEN }}
      DIGITALOCEAN_ACCESS_TOKEN: ${{ secrets.DO_API_TOKEN }}
      SPACES_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY }}
      SPACES_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_KEY }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Generate SSH Key
        id: ssh_key
        run: |
          # Create SSH directory
          mkdir -p ~/.ssh
          
          # Generate a new SSH key pair
          ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa -N ""
          
          # Output the public key (will be used in Terraform)
          echo "SSH_PUBLIC_KEY=$(cat ~/.ssh/id_rsa.pub)" >> $GITHUB_ENV
          
          # Configure SSH to not check host keys
          cat > ~/.ssh/config << 'EOF'
          Host *
            StrictHostKeyChecking no
            UserKnownHostsFile=/dev/null
          EOF
          chmod 600 ~/.ssh/config
          
          # Set permissions on private key
          chmod 600 ~/.ssh/id_rsa
          
          # Display SSH key files for debugging
          ls -la ~/.ssh/

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      - name: Create Terraform Variables File
        working-directory: ./terraform
        run: |
          cat > terraform.tfvars << EOF
          do_token="${{ secrets.DO_API_TOKEN }}"
          environment="staging"
          jwt_secret="${{ secrets.JWT_SECRET }}"
          cookie_secret="${{ secrets.COOKIE_SECRET }}"
          revalidate_secret="${{ secrets.REVALIDATE_SECRET }}"
          admin_email="${{ secrets.ADMIN_EMAIL }}"
          admin_password="${{ secrets.ADMIN_PASSWORD }}"
          resend_api_key="${{ secrets.RESEND_API_KEY }}"
          spaces_access_key="${{ secrets.SPACES_ACCESS_KEY }}"
          spaces_secret_key="${{ secrets.SPACES_SECRET_KEY }}"
          ssh_private_key_path="$HOME/.ssh/id_rsa"
          ssh_public_key="${{ env.SSH_PUBLIC_KEY }}"
          EOF

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Destroy Existing Infrastructure
        working-directory: ./terraform
        run: |
          # Target database resources first since they're causing issues
          echo "Destroying database resources..."
          terraform destroy -auto-approve -var-file="terraform.tfvars" \
            -target=module.postgres_db.digitalocean_database_cluster.this \
            -target=module.redis_db.digitalocean_database_cluster.redis
          
          # Then destroy the droplets
          echo "Destroying droplet resources..."
          terraform destroy -auto-approve -var-file="terraform.tfvars" \
            -target=module.backend_droplet \
            -target=module.storefront_droplet
          
          # Finally attempt a full destroy for any remaining resources
          echo "Performing full destroy for remaining resources..."
          terraform destroy -auto-approve -var-file="terraform.tfvars"
          
          # Verify the state is empty or show what's left
          terraform state list || echo "State is empty or has issues"
      
      - name: Terraform Apply
        working-directory: ./terraform
        run: |
          # Print the directory with the SSH key to confirm its location
          echo "SSH key location: $HOME/.ssh/id_rsa"
          ls -la $HOME/.ssh/
          
          # Plan the changes
          terraform plan -var-file="terraform.tfvars"
          
          # Apply full Terraform configuration to create all resources
          terraform apply -auto-approve -var-file="terraform.tfvars"
        
      - name: Get Server IPs
        id: server_ips
        working-directory: ./terraform
        run: |
          # Get IPs from the terraform outputs and clean up any debug output
          BACKEND_IP=$(terraform output -raw backend_ip | cut -d: -f1)
          STOREFRONT_IP=$(terraform output -raw storefront_ip | cut -d: -f1)
          
          # Set GitHub outputs using the correct syntax for newer GitHub Actions
          echo "backend_ip=$BACKEND_IP" >> "$GITHUB_OUTPUT"
          echo "storefront_ip=$STOREFRONT_IP" >> "$GITHUB_OUTPUT"
          
          # Debug output
          echo "Backend IP: $BACKEND_IP"
          echo "Storefront IP: $STOREFRONT_IP"
      
      - name: Wait for servers to initialize
        run: |
          echo "Waiting 90 seconds for servers to initialize..."
          sleep 90
      
      - name: Setup Environment Variables
        working-directory: ./scripts
        run: |
          BACKEND_IP="${{ steps.server_ips.outputs.backend_ip }}"
          STOREFRONT_IP="${{ steps.server_ips.outputs.storefront_ip }}"
          ./setup-env.sh staging $BACKEND_IP $STOREFRONT_IP
      
      - name: Deploy Backend
        working-directory: ./scripts
        run: |
          BACKEND_IP="${{ steps.server_ips.outputs.backend_ip }}"
          ./deploy-backend.sh staging $BACKEND_IP
      
      - name: Deploy Storefront
        working-directory: ./scripts
        run: |
          STOREFRONT_IP="${{ steps.server_ips.outputs.storefront_ip }}"
          ./deploy-storefront.sh staging $STOREFRONT_IP
      
      - name: Display Deployment Info
        working-directory: ./terraform
        run: |
          echo "Backend IP: $(terraform output -raw backend_ip)"
          echo "Storefront IP: $(terraform output -raw storefront_ip)"
          echo "API URL: $(terraform output -raw api_url)"
          echo "Admin URL: $(terraform output -raw admin_url)"
          echo "Storefront URL: $(terraform output -raw storefront_url)"
      
      - name: Verify SSL certificates
        working-directory: ./terraform
        run: |
          echo "Checking API SSL certificate..."
          API_URL=$(terraform output -raw api_url)
          SSL_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $API_URL || echo "Failed")
          echo "API SSL check returned: $SSL_STATUS"
          
          echo "Checking Admin SSL certificate..."
          ADMIN_URL=$(terraform output -raw admin_url)
          SSL_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $ADMIN_URL || echo "Failed")
          echo "Admin SSL check returned: $SSL_STATUS"
          
          echo "Checking Storefront SSL certificate..."
          STOREFRONT_URL=$(terraform output -raw storefront_url)
          SSL_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $STOREFRONT_URL || echo "Failed")
          echo "Storefront SSL check returned: $SSL_STATUS"
      
      - name: Verify API health
        run: |
          API_URL=$(cd terraform && terraform output -raw api_url)
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" $API_URL/health || echo "Failed")
          echo "API health check returned: $STATUS"
          if [[ "$STATUS" != "200" ]]; then
            echo "Warning: API may not be fully available yet. This is expected after initial deployment."
          fi 